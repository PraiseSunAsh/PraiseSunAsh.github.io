{"meta":{"title":"PraiseSunAsh","subtitle":"赋时光以生命","description":" ","author":"Asher","url":"http://PraiseSunAsh.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-04T11:36:10.000Z","updated":"2019-07-04T11:36:23.212Z","comments":true,"path":"about/index.html","permalink":"http://PraiseSunAsh.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-04T11:35:24.000Z","updated":"2019-07-04T11:35:41.951Z","comments":true,"path":"tags/index.html","permalink":"http://PraiseSunAsh.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-04T11:33:04.000Z","updated":"2019-07-04T11:33:38.912Z","comments":true,"path":"categories/index.html","permalink":"http://PraiseSunAsh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络第三弹","slug":"计算机网络第三弹","date":"2019-07-08T06:07:18.000Z","updated":"2019-07-08T11:26:19.204Z","comments":true,"path":"2019/07/08/ji-suan-ji-wang-luo-di-san-dan/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/08/ji-suan-ji-wang-luo-di-san-dan/","excerpt":"","text":"万维网（World Wide Web）万维网的本质还是程序，但这个程序需要配合浏览器使用 页面是构成万维网的基本单位，页面中存在大量的超链接(见下),这些超链接使得每个页面相互连接，这也是万维网的由来。 超链接需求当需要查看其他信息时，早期计算机只能从文件系统手动打开或者输入URL(见下)。 定义去往其他页面的链接，存在这种链接的文本被称之为超文本 URL统一资源定位器，通常用于描述网页和文件的位置。 HTTP超文本传输协议，当计算机访问到服务器后，要在这个协议下获得具体的页面。 第一个HTTP版本只有一个”GET”指令，后面的版本逐步添加了状态码 常见状态码 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 HTML超文本标记语言，现代网页的“骨架”。 这是一个简单的页面，里面用到了 h1，h2标签，a标签，ol标签等等。具体标签功能请前往菜鸟教程查看。 要让网页实现复杂的功能单单依靠HTML是不够的，还需要CSS和JavaScript。 第一个浏览器和服务器诞生于1990年，开发者是Tim Berners-Lee(前端祖师爷啊)，URL,HTML,以及HTTP都是他建立的。 1991年发布，万维网由此诞生！ 万维网的标准是开放的，因此所有人都可以为其开发浏览器和服务器。 搜索引擎需求最开始人们为了便于查询信息创建了网页链接目录（网站导航）,但随着页面规模的扩大想快速找到特定页面变得越来越困难。 组成 爬虫。一个跟着链接到处跑的软件，每当看到新链接，就会将其添加到自己的列表中。 索引。用于记录访问的网页上出现过哪些词。 查询索引的算法。Google早期由于其出色的搜索算法而出名。 网络中立性是一种原则，要求互联网服务供应商以及政府应平等的处理所有互联网信息。目前仍处于争论之中。 OSI七层模型 从下向上依次为 物理层：线路里的点信号，无线网络里的无限信号 数据链路层：负责操作物理层。其中有mac地址，碰撞检测，指数退避以及其他的底层协议。 网络层：操作数据链路层。负责报文交换和路由问题。 传输层：负责计算机间的信息传输，UDP和TCP运作在这一层。 会话层：会话层会使用UDP和TCP来创建连接，传递信息，关闭连接。 表示层：表示层负责将数据转换为用户或应用程序需要的格式。 应用程序层：为应用程序提供接口，负责应用间的消息传递。如HTTP，SSH","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://PraiseSunAsh.github.io/categories/计算机网络/"}],"tags":[{"name":"万维网","slug":"万维网","permalink":"http://PraiseSunAsh.github.io/tags/万维网/"},{"name":"超链接","slug":"超链接","permalink":"http://PraiseSunAsh.github.io/tags/超链接/"},{"name":"OSI七层模型","slug":"OSI七层模型","permalink":"http://PraiseSunAsh.github.io/tags/OSI七层模型/"}]},{"title":"计算机网络第二弹","slug":"计算机网络第二弹","date":"2019-07-07T10:58:34.000Z","updated":"2019-07-08T11:30:51.746Z","comments":true,"path":"2019/07/07/ji-suan-ji-wang-luo-di-er-dan/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/07/ji-suan-ji-wang-luo-di-er-dan/","excerpt":"","text":"IP(Internet Protocol) - 互联网协议一个标准，就像邮件，每逢邮件必须有地址，必须有收发信人，每封邮件都必须遵循这个标准才能送出去。 数据包也是如此。 互联网协议是一个很底层的协议，从图中就成看出。 组成头部：存放目标地址，也就是元数据(metadata)。 尾部 : 存放要传输数据流。 UDP(User Datagram Protocol) - 用户数据协议组成 UDP头部: 存放一些更详细的信息，其中也包括端口号和校验和。 端口号：操作系统概念，每个要访问网络的app都需要像OS申请一个端口号。数据包中的端口号可以让操作系统明白一个数据包到底要给哪个应用程序。 校验和(Checksum)：16位二进制数的一串数据，用于检查数据是否正确。 特点不支持数据修复和数据重发机制（无法实现断点续传），接收方得知数据损坏只能扔掉。 但是UDP简单并且迅速，适合即时通讯和网络游戏这类应用程序，不像TCP那样一定要等确认码。 TCP(Transmission Control Protocol) - 传输控制协议组成 TCP头部：也有端口号和校验和。 特点 每个数据包中有序号，这使得接收方可以很容易讲数据包排成正确的顺序，即使到达时间不同。 在TCP协议中，接收方的计算机在每次收到数据包并通过校验和检查无误后，会给发送方反馈一个确认码(ACK)，代表收到了。这时才会继续传输下一个数据包。确认码的成功率和来回时间可以用来判断网络状况，计算机可以利用这个信息调整发包速率，缓解拥堵问题。 DNS(Domain Name System) - 域名系统一个专门为每台服务器做的“电话簿”，域名由服务商提供。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://PraiseSunAsh.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://PraiseSunAsh.github.io/tags/计算机网络/"},{"name":"UDP","slug":"UDP","permalink":"http://PraiseSunAsh.github.io/tags/UDP/"},{"name":"TCP","slug":"TCP","permalink":"http://PraiseSunAsh.github.io/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"http://PraiseSunAsh.github.io/tags/IP/"}]},{"title":"计算机网络第一弹","slug":"计算机网络第一弹","date":"2019-07-07T07:08:41.000Z","updated":"2019-07-08T11:28:55.844Z","comments":true,"path":"2019/07/07/ji-suan-ji-wang-luo-di-yi-dan/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/07/ji-suan-ji-wang-luo-di-yi-dan/","excerpt":"","text":"本系列是根据Crash Course Computer Science P28到 P30总结的笔记，部分定义参考维基百科，为了便于理解有些概念解释的可能不是很严谨，如有错误欢迎指出 (｀・ω・´) 课程链接不放了，自行B站搜索”计算机速成课” 局域网（LAN）定义计算机间近距离构成的小型网络 以太网局域网的实现之一，相对而言最成功 （1970） ps:最简单的实现形式就是一根网线(所谓的以太网电线)连着多台计算机 广域网(WAN)由局域网组成的网络 ISP:互联网服务提供商，WAN的路由器一般归他们管(移动，联通，电信) MAC（媒体访问控制）需求当数据在网线中走的时候，计算机无法判断数据是给自己的还是给其他设备的。此时只需要在每个传输的数据包前缀加上目标计算机的mac地址，目标计算机在监听网线数据的时候一看是给自己的，就会监听这段数据。 ps：通常是指物理地址，比如有熊孩子蹭你家wifi，此时你禁掉他的网络其本质就是把他的mac地址拉黑 CSMA(Carrier Sense Multiple Access/载波侦听多路访问)定义是实现MAC的一种协议 Carrier（载体/载波）对于以太网就是铜线，对于Wifi就是空气 Carrier Sense(载波侦听)是指计算机在以太网中的计算机在发送数据前 ，必须对介质进行监听，当确认介质空闲时，才可以发送。 Multiple Access（多路访问）:多台计算机可以连一根网线，一台计算机发送的信息也能被多台计算机接收。 宽带载体传输数据的速度 指数退避一种算法，用于描述某些进程。比如当你没网的时候隔1分钟会重新拨号，如果拨号失败隔两分钟会再试一次，再失败会隔四分钟再试一次，时间间隔呈指数级增加。 冲突域网络载体和在其中设备的总称。 上述就构成了一个冲突域 交换机一种网络设备，意义重大 ps：交换机可以更好的避免数据冲突，互联网也是这样构建出来的。 pps：注意一个细节，交换机使得一台pc到另一台pc之间有多条路线可以走，这就引出了路由的问题。 路由定义：在网络中把一个信息从源送到目标的这个过程。 电路交换传输数据的一种方式，用专门的线路来传输数据。以前在老式电话中用的较多，但目前一些重要机构(银行，军队)仍会采用这种方式。 报文互换(存储转发交换)传输数据的另一种方式，存储接收的信息，然后根据其目标选择线路。比电路交换要灵活。 跳数(hop count)消息经过结点的次数，可以用来判断路由问题。 ps：可以用traceroute查看跳了几次 从图中可以看出这个数据经历了11次中转 分组交换将数据拆成多个数据包，然后通过路由传递。 IP(Internet protocol/互联网协议)规范了每个报文的具体格式 IP地址一组以点分隔的四组数字，用来记录服务器的地址。 阻塞控制路由器会平衡与其他路由器间的负载，以确保传输可以快速可靠。 TCP/IP用于解决数据包到达目标后的乱序问题。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://PraiseSunAsh.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://PraiseSunAsh.github.io/tags/计算机网络/"},{"name":"LAN","slug":"LAN","permalink":"http://PraiseSunAsh.github.io/tags/LAN/"},{"name":"CSMA","slug":"CSMA","permalink":"http://PraiseSunAsh.github.io/tags/CSMA/"}]},{"title":"32天火速入门前端开发指南","slug":"32天火速入门前端开发指南","date":"2019-07-05T11:11:18.000Z","updated":"2019-07-07T10:42:25.604Z","comments":true,"path":"2019/07/05/32-tian-huo-su-ru-men-qian-duan-kai-fa-zhi-nan/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/05/32-tian-huo-su-ru-men-qian-duan-kai-fa-zhi-nan/","excerpt":"","text":"前言​ 本人与今年的3.26日正式开始折腾前端开发。为什么是这天呢？因为在3月25号之前一直在折腾算法比赛(PS:当然最后划水了，嘤嘤嘤),也没时间搞别的东西了。其实对于我而言转移方向到前端上来是一个挺痛苦的过程，因为自打从中学起我就一直想做一个Android developer，但几经分析行情以及自身实力最终还是决定放弃移动开发，深层次原因暂且不表。在接下来的时间，我大概用了将近两个月的时间系统的掌握了(装尼玛呢)前端开发的核心技能，之后就能差不多去做一些东西了(主要是小程序),写这篇路线规划一方面对自己过去的这段时间做个总结，另一方面也算是给准备搞前端的小萌新们一个参考吧。 学习资源推荐 表严肃一个前端讲的很nice的讲师，课程质量很高，个人网站绝大部分都是免费课程。也可以去B站搜”表严肃”。 mooc平台：中国大学mooc/学堂在线/网易云课堂 Wiki:菜鸟教程 极客学院Wiki 闲鱼(滑稽 具体的路线规划接下来是根据我自己的学习经验总结的路线，如果你无从下手，就这样跟着走吧，至少我敢保证这种学习路线还是很平滑的。你每天大概只需要抽出三到四个小时，当然这指的是你集中精力的时间。 第1天到第2天(HTML)可以去看这个培训班的视频 链接 在P32之前的部分都是HTML，其实这部分很简单的，你也可以去菜鸟教程上去看Wiki，跟着做也是一个不错的选择，不过我还是推荐看一下这个视频，他会把一些很基础的东西交给你，对新人来说还算友好，我当初记得一天就刷完了。 第3天到第9天(CSS)CSS火速入门 这部分的内容掌握常用的就ok，当然基本的概念(盒子模型/display/position属性、常见布局)一定要搞懂，虽说不难但每次写个页面都查文档还是很恶心的，这个地方建议去看表严肃，讲的很精炼，我当初看的还是上个链接中培训班的视频，往后几天差不多就看完了，不建议去看wiki，现用先查也算是一种不错的学习方式。在学习的过程中尽量跟着敲，用一些笔记软件(推荐onenote)把效果截图截下来，这步很重要！当然你懒得话也可以截视频里的图，这都没有问题，只要你觉得你能记得住。 第10天到第11天(简易博客)简易博客搭建 利用之前的知识做一个简单的博客。 第12天(响应式布局)响应式布局 理解什么是所谓的响应式布局(很简单的，就是为不同设备写不同样式表) 第13天到第14天(电商布局)电商布局 复杂的页面真的可以锻炼布局能力，不要偷懒，跟着好好做。 第15天到第16天(Git与Github)Git与Github 写这么久代码如果连全球最大同性交友网站还不会玩那可太low了。这个视频可能你会看的一头雾水，但没关系只要你会用就行了，其实就那几条命令。一些复杂的(合并分支版本控制啥的)现阶段真的用不到。搞明白后记得把你之前跟着写的那两个项目推到你的github上(你也可以把你之前写过的东西放上去)。 第17天到第18天(bootstrap)bootstrap bootstrap是一个很好用的css框架，可以极大的提升你写布局的效率。 第19天到第20天(新闻站开发)新闻站开发 利用前两天学的框架做一个新闻网站。 目前为止你大概就把html和css的基础部分差不多搞完了，现在开始就是真正重要的内容了。 第21天到第22天（JavaScript预科）翁凯JavaScript 讲的不是很详细，但很适合拿来预科，提前了解下JavaScript这门语言，翁凯也确实是一个姿势水平很高的老师。 第23天到第25天(Javascript高级程序设计)这部分的内容并不推荐视频，因为真的太太太太重要了，推荐看书，书名就叫JavaScript高级程序设计(就是所谓的红宝书,豆瓣评分9.3的那个)，这本书号称前端圣经，面试中90%以上的问题都能在这里找到答案。当然把这本书通读完也是不现实的，我列一下重点章节吧 第三章 基本概念 第四章 变量，作用域和内存问题 第五章 引用类型（5.1，5.2，5.5，5.6）剩下的部分可以先暂时不用看。 第六章 面向对象程序设计 第七章 函数表达式 第二十章 JSON 看的时候也不要卡牛角尖，主要是把这本书上的代码示例跟着敲敲搞明白就好，给你们一个参考，这里是我当时总结的 JavaScriptLearning 这本书的链接JavaScript高级程序设计第三版pdf版 这本书还是写的很不错的，推荐搞一本，闲鱼或者多抓鱼上二手的也不是很贵。如果说你真的看书看不下去，emmmmmm那好吧，这个清华大学的mooc讲的也还行(看第六章和第七章的7.3) Web前端攻城狮 第26到第27天（Dom与Bom）DOM 这部分也应该归到js里面，但因为很重要就单独拿出来了 第28到第29天（JQuery）JQuery 虽说现在一线的前端开发已经很少用JQuery了，但这个框架的思想还是值得学习的，还是好好看看吧。 第30到第32天（Vue）Vue.js精讲 Vue应该算是目前为止最流行的框架了(???完了我这样说是有可能被砍的)，这个框架的作者是个华人，而且长得巨TM帅(误，Vue在所有js框架中应该算是对萌新相对比较友好的一个，当然你也可以选择去学习react或者angular，框架这种东西只要能用的顺手就行了。哦，这部分我根据课程内容总结了一份源码，感兴趣可以看看 课程源码 结语好了，目前为止你应该能做一点东西了，接下来的发展方向看你的喜好吧。如果你想做移动端前端开发可以联系我，目前我们在开发一些小程序，项目确实需要一些人手，如果你想做PC浏览器端的前端开发那你需要研究下node.js/npm、webpack之类的工具，不管怎么说如果你真的能每天肝三小时把上述内容搞明白的话，你就已经算是入门前端开发了。万事开头难，接下来你就能做很多事情了：去写一个属于你的博客，或者是一个WebApp，或者给你喜欢的妹子写一个炫酷的页面拿来表白(误。。当然这上面的内容是远远不够的，要不然怎么叫入门呢。。。你还需要根据你自己的项目需求去掌握一些必要的技术栈，这都是一个不断爬坑的过程，在这些过程中希望你能自己善于总结，吸取经验，毕竟写代码真的是一件你付出多少它就给你回馈多少的事情。","categories":[],"tags":[{"name":"路径规划","slug":"路径规划","permalink":"http://PraiseSunAsh.github.io/tags/路径规划/"},{"name":"前端","slug":"前端","permalink":"http://PraiseSunAsh.github.io/tags/前端/"}]},{"title":"换种方式描述递归","slug":"换种方式描述递归","date":"2019-07-03T14:46:14.000Z","updated":"2019-07-07T10:43:34.454Z","comments":true,"path":"2019/07/03/huan-chong-fang-shi-miao-shu-di-gui/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/03/huan-chong-fang-shi-miao-shu-di-gui/","excerpt":"","text":"递归作为算法中的重要思想，在编程的应用中可以说是相当广泛。但递归又由于其本身的抽象性，对于初学者而言理解起来相当困难。作为一个初学算法的菜鸡，想和大家分享一下自己理解递归的方式，如有错误和不妥，还望大佬指出。 ​ 首先我们要明白，一个递归函数内部肯定长这样 也就是说，递归函数的终止条件一定要在递归函数的上面，否则递归函数就像一个没有底的坑，掉进去就永远出不来了。而如何写出递归函数的关键在于：找出解决问题的“笼统方法”。 ​ 而解决问题的“笼统方法”又分为三种表现形式。 “笼统方法”表现的第一种形式：直接解决这个问题的一小部分+递归解决这个问题的剩余部分​ eg1：求n的阶乘 ​ 这是个非常简单的例子，但也给很多初学递归的人一种错觉：“哦这玩意儿就是递归啊，也没说的那么难理解嘛”，如果真是这样想的，那你可真的是naive。这只是递归的最简单的表现形式，但对于我们而言仍有大篇幅讨论的必要。假如说你现在是个完完全全的小白，你拿到这个问题首先应该想的是：这个问题我应该咋给他“应付”过去？ ​ 看看递归的程序是怎么“应付”的。 ​ 要想找n的阶乘，我只需要找出n-1的阶乘，然后把他和n乘一块儿，至于n-1的阶乘改咋办？抱歉那就不是我的事儿了，您找下一层解决去吧。有没有觉得这种程序风格让人觉得很敷衍？其实递归程序都是这种敷衍的风格，正由于它的“敷衍”导致递归函数的时间复杂度非常的糟糕。在这个例子中，n* 直接解决了这个问题的一部分，fac（n-1）则解决了这个问题的剩余部分，二者拼凑起来，就成了解决这个问题的“笼统方法”。找出笼统方法还不行，如果这个程序就这样一直敷衍下去那么问题肯定是没有办法解决的，总要有一个不敷衍人完成具体的工作，这就是递归程序中的边界条件。这个问题的简单之处就在于它的边界条件很好找，n最多只能减到1，那就返回1给上层函数就好了。但接下来的这和例子的边界条件找起来就要稍微麻烦些了。 eg2：求一个数组的和 ​ 这个程序用层for循环就能轻松解决，但我们现在讨论的是递归，我想你应该没有那么无聊。其实对于初学者来说，把循环改写为递归也算是一种不错的训练方式。废话不多说，直接上码 ​ 这里我们在传参数的时候我们除了将数组传进去之外，还多传了一个begin。因为如果不传这个begin的话，我们没有办法切割这个数组，也就没有办法去“笼统”的解决这个问题，最终的边界条件就更没法儿找了。在这段代码中，a[begin]+ 解决了这个问题的一部分，sum（a，begin+1）解决了这个问题的剩余部分。边界条件肯定就是begin跑到数组的最后，然后返回那个位置上的值就可以了。 “笼统方法”表现的第二种形式：递归解决问题的一部分+递归解决问题的一部分+……​ emmm，我举一个最形象的例子，假如你现在在进行期末“预习”备考，你肯定不会从头到尾翻一遍书，你最多把老师们画的重点例题好好研究一下。但你一学期啥也没学啊，而一道题又恰好涉及到了多个知识点，这时候你能做的就是把这道题涉及到的知识点好好看一下然后去搞懂，如果这道题的知识点牵连到了其他的知识，这时你就只有把那些“子知识”搞懂你才能搞懂“父知识”，当你把重点题中的某个“父知识”搞明白后，就可以说你递归解决了这个问题的一部分。但还有另一部分那些“父知识”等着你递归解决呢伙计。其实这个过程就算是这样的表现形式，你上百度百科上去查相关词条其实也算是这种表现形式。 ​ eg1：返回斐波那契数列中的第i个元素 ​ 上码： ​ 这个例子可以说是很典型了。在这个例子中 fib(i-1) 解决了原问题的一部分，fib(i-2) 解决了这个问题的另一部分，二者加一块拼凑起来就解决了原问题。 ​ eg2：汉诺塔问题 ​ 只要你小时候你们家买过国产山寨按键机，我猜你们应该都玩过这个游戏，汉诺塔的规则我就不解释了，没玩过的可以自己去玩一下。（汉诺塔游戏）我们通常玩到的版本通常是只有三层四层或五层，其实原问题是那个印度神棍要把49层挪到目标柱子（她真要挪的话挪到太阳踏缩成黑洞都挪不完），但不管是挪3层还是49层，他们的本质都是一样的：把从上往下那n-1个盘子挪到空闲的柱子上作为辅助空间，把最底下那个最大的盘子（第n个）挪到目标柱子上，最后把那n-1个盘子挪到目标柱子上，所以所一共下来只要三步，无非是第一步和第三步需要递归完成。 ​ 这段代码描述的是挪的步骤，n是指从上往下第几个盘子 边界的极端情况，以三个为例 此时左边还剩一个，直接挪到目标柱上即可完成。 “笼统方法”表现的第三种形式：解决了子问题，就等于解决了原问题。​ 这种形式的递归问题可以说是最难解决的，因为相对应的等价问题并不是那么好找。比如求两个数的最大公约数的递归算法。 这段代码看似简单，但如果没人提醒一句“要用辗转相除法”是绝对不太好想的，举个栗子，要想求出18与12的最大公约数那就等价于求12与6的最大公约数，就等价于求6与0的最大公约数。第一次进行等价问题的转化才是最难的，这种类似问题也对编程学习者的数学转化能力有所要求。 ​ 最后一点需要强调，如何找出边界条件。我们要把目光放到变化的量上面，通常是将变化的量做为参数传入递归函数，进行边界条件判断时也是依据变化的量的极端情况进行判断的。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://PraiseSunAsh.github.io/tags/算法/"},{"name":"递归","slug":"递归","permalink":"http://PraiseSunAsh.github.io/tags/递归/"},{"name":"Java","slug":"Java","permalink":"http://PraiseSunAsh.github.io/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-03T13:58:47.579Z","updated":"2019-07-03T13:58:47.579Z","comments":true,"path":"2019/07/03/hello-world/","link":"","permalink":"http://PraiseSunAsh.github.io/2019/07/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}